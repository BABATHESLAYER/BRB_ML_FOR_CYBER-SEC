# This is the main entry point for the Flask web application.
# It provides a simple web interface to display the threat intelligence report
# generated by the autoti pipeline.

from flask import Flask, render_template_string
import sys
import os

# --- PATH CONFIGURATION ---
# This ensures that the 'autoti' package can be imported correctly.
# When the app is run, Python needs to know where to find the 'autoti' directory.
# We add the project's root directory to the Python path.
# This is crucial for the application to function when deployed.
sys.path.insert(0, os.path.abspath(os.path.dirname(__file__)))


# --- DYNAMIC PIPELINE IMPORT ---
# We try to import the main 'run_pipeline' function from the autoti package.
# If there's an ImportError (e.g., due to missing dependencies or misconfiguration),
# we catch it and define a dummy 'run_pipeline' function.
# This allows the Flask app to still run and display a useful error message
# instead of crashing completely.
IMPORT_ERROR_MESSAGE = None
try:
    from autoti.analysis.langchain_agent import run_pipeline
except ImportError as e:
    IMPORT_ERROR_MESSAGE = str(e)
    print(f"FATAL ERROR: Could not import run_pipeline. Error: {IMPORT_ERROR_MESSAGE}")
    
    def run_pipeline():
        """A dummy function that returns an error message if the import fails."""
        return f"Application initialization failed. Import error: {IMPORT_ERROR_MESSAGE}"

# Initialize the Flask application.
app = Flask(__name__)


# --- HTML TEMPLATE ---
# A simple, self-contained HTML template for displaying the report.
# Using a multiline string here avoids the need for separate template files,
# making the application easy to manage as a single file.
REPORT_TEMPLATE = """
<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Threat Intelligence Report</title>
    <style>
        /* Basic styling for a clean, modern look. */
        body { 
            font-family: 'Inter', sans-serif; 
            margin: 0; 
            padding: 20px;
            background-color: #f0f4f8;
            color: #1f2937;
        }
        .container {
            max-width: 1000px;
            margin: 0 auto;
            background-color: #ffffff;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }
        h1 { 
            color: #111827; 
            font-size: 2.25rem;
            border-bottom: 2px solid #e5e7eb;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        pre { 
            background-color: #1f2937; 
            color: #d1d5db; 
            padding: 20px; 
            border-radius: 8px;
            white-space: pre-wrap; 
            word-wrap: break-word; 
            line-height: 1.6;
        }
        .error {
            color: #b91c1c;
            background-color: #fee2e2;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #fca5a5;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Automated Threat Intelligence Executive Summary</h1>
        <p>Report generated on demand using OTX data and Gemini LLM analysis.</p>
        <!-- The 'report_content' will be replaced by the output of the pipeline. -->
        <pre>{{ report_content }}</pre>
    </div>
</body>
</html>
"""

# --- FLASK ROUTE ---
@app.route('/')
def report():
    """
    The main route for the web application.
    When a user visits the root URL, this function is called.
    It runs the full threat intelligence pipeline and displays the result.
    """
    try:
        # Execute the main pipeline function to get the report text.
        print("Starting pipeline for web request...")
        report_text = run_pipeline()
    except Exception as e:
        # If any other unexpected error occurs during the pipeline execution,
        # format it into an error message to be displayed on the web page.
        report_text = f"<div class='error'><strong>Report Generation Error!</strong><br>The pipeline failed to execute.<br>Error: {e}</div>"
        print(f"Flask App Error: {e}")

    # Render the HTML template, passing the generated report content to it.
    return render_template_string(REPORT_TEMPLATE, report_content=report_text)


# --- LOCAL DEVELOPMENT SERVER ---
if __name__ == '__main__':
    # This block allows the Flask app to be run directly for local testing
    # (e.g., by running 'python app.py').
    # In a production environment (like Docker), a proper WSGI server like Gunicorn
    # will be used to run the app, so this part won't be executed.
    app.run(host='0.0.0.0', port=5000)
